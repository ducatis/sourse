import checkNumInputs from './checkNumInputs';

const forms = () => {
    const form = document.querySelectorAll('form'), // Берём все формы из вёрстки.
          inputs = document.querySelectorAll('input'); // // Берём все инпуты из вёрстки
          
    checkNumInputs('input[name="user_phone"]');

    const message = {  // Создаём переменную, в которую кладём объект с сообщениями.
        loading: "Идет отправка...",
        success: "Отправлено",
        failure: "Ошибка"
    };
    
    const postData = async (url, data) => { // Тело запроса отправляем на сервер при помощи fetch-API. Для запуска fetch'a нам понадобится два аргумента (url, data). Первый - это адрес куда мы будем отправлять этот запрос. Второй это данные которые будут уходть на сервер. Поскольку fetch - это асинхронная, операция. То мы прописываем async, что бы сказать JavaScript коду, что когда наткнешься на async, то имей ввиду, что в этой функции есть асинхронный код.
        document.querySelector('.status').textContent = message.loading; // Достаём класс из вёрски и помещаем в него сообщение из объекта message => loading => Идёт отправка. 
        let res = await fetch(url, { // В fetch мы передаём те аргумент которые созали выше. Первый - это url. А вторым аргументом настраиваем наш запрос - что должно происходить при этом fetch'e. При помощи await мы говроим JavaScrip, что именно эту операцию надо дождаться. И только тогда, когда придет ответ от сервера, он запишется в меременную res. Fetch принимает в себя promis.
            method: "POST", // Указывем метод "POST". Так как мы будем постить на сервер.
            body: data // Тело запроса. Используется только, при POST запросах. По скольку мы отправляем FormData, то заголовок нам не нужен.
        });

        return await res.text(); // return возвращает полученные данные от переменной res и переводит их в текстовые данные. И поскольку это тоже асинхронная операция. ТО мы добавим await.

    };

    const clearInputs = () => {  // Отдельно вынесенная функция по очищению инпутов.
        inputs.forEach(item => { // Берём переменную inputs, далее перебираем.
            item.value = ''; // Берём каждый инпут и в его value записываем пустую строку. Таким образом у нас очистятся инпуты
        });
    };

    form.forEach(item =>  {  // Перебераем все формы.
        item.addEventListener('submit', (e) => { // Каждой форме навешиваем событие submit
            e.preventDefault(); // Отменяем обновления страницы при отправке формы
            
            let statusMessage = document.createElement('div'); // Создаём переменную, куда помещаем новый div.
            statusMessage.classList.add('status'); // Далее к созданному div'у добавляем класс для стилизации
            item.appendChild(statusMessage); // К каждой форме на сайте, в конец её вёрстки добавляем выше созданный div.

            const formData = new FormData(item); // Создаём переменную куда добавляем конструктор FormData который собирает все данные, которые есть у нас в форме. То есть этот конструктор найдёт все инпуты, и из них соберёт все данные в специальную структуру, и эту структура помещает в переменную const formData. Причём при помощи конструктора FormData можно загружать всё что угодно, туда пойдут и изображения и файлы которые можем прикрепить на свой сайт. Но сдесь есть небольшой ньюанс, что в таком виде мы можем отправить такие данные на сервер именно саму FormDat'у и она отлично отработает на сервере. Но тут нам надо знать, что именно наш сервер принимает, возможно он принимает URL-encoded формат, возмможно ему нужен JSON формат. В зависимости от этого мы будем отправлять нужный запрос. В этом примере мы оставили формат FormData, но если нам понадобиться формат JSON то мы это с легкостью сделаем. Следующим этапом будет написание самого запроса. И нам необходимо тело body(переменная formData) отправить на сервер. И делать это мы будем с помощью fetch-API
            postData('assets/server.php', formData) // Вызываем ту функцию, которая отправляет наш запрос на сервер. Первым аргументом мы прописываем путь до нашего серверного файла "server.php", этот файл в виде строки возвращает массив тех данных которые пользователь вписал в форму. Вторым аргументом мы записываем те данные которые хотим отправить на сервер - это переменная formData.
                .then(res => { // Так как сдесь нам возвращается promis, то мы прописываем цепочку. То есть в этот then нам попадает какой-то результат который прислал нам сервер, причем в текстовом формате. Аргументом res (result) мы говорим, что к нам возвращается какой-то результат
                    console.log(res); // не имеет смысла, тут мы просто хоти посмотреть на res.
                    statusMessage.textContent = message.success; // Если успешно прошел этот запрос, мы сообщаем это пользователю.
                })
                .catch(() => statusMessage.textContent = message.failure) // Обрабатываем ошибку при помощи catch. И выводим текст с ошибкой, из того объекта в котором лежит текст.
                .finally(() => { // finaly выполниться в любом случае, не важно промис у нас ушел в положительную, либо в отрицательну.
                    clearInputs(); // Вызываем отдельно вынесенную функцию по очищению инпутов.
                    setTimeout(() => { // Создаём таймаут с функцией, что через 5 секунд удалим div с нашими сообщениями.
                        statusMessage.remove();
                    }, 5000);
                });
        });
    });
};

export default forms;